# План
---
### Подготовления
1. У пользователей приложения возможны только 3 роли (READ, WRITE, EXECUTE) -> введем _**enum**_ тих ролей
2. Сведения о ролях соответсвующим конкретным пользователям должны храниться в отдельном файле или sql-таблице 
3. В отдельном файле или sql-таблице хранится логины и хэшированные пароли пользователей, а так же сгенерированные при регистрации соли
4. Для удобной работы с пользователями создадим класс User, хранящий логин, хэшированный пароль и роль

### Аутентификация (R1.1)
1. Для авторизации создадим класс IdentityProvider, использующий для извлечения данных из источника data.Service.  
Provider сравнивает введеные пользователем данные с найдеными в базе. Возможные ошибки:
    * пользователя с таким логином не существует _**(exit code 3)**_
    * пароль для указанного логина не верный  _**(exit code 4)**_
2. При запросе на аутентификацию Provider отправляет в data.Service запрос на поиск учетки с указанным логином в базе данных.  
Если такого пользователя в базе нет, выбрасываем первую ошибку (см выше), иначе хэшируем введенный пароль и сравниваем с полученным data.Service-ом.
3. При успешной аутентификации производим авторизацию, иначе выбрасываем вторую ошибку.
### Хранение пароля (R1.2)
1. Для хэширования используем уже реализованный java.security.MessageDigest
2. Соли генерируюся случайным образом при регистрации и хранятся вместе с логином и паролем
### Авторизация (R1.3)
1. Для авторизации создадим AuthorityProvider, использующий data.Service для доступа к данным ролей пользователей
2. После успешной работы IdentityProvider-а AuthorityProvider передает запрос в свой data.Service запрос на поиск ролей пользователя.  
3. После успешной авторизации свойство role в узера устанавливается.
---